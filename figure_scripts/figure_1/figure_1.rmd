---
title: "Figure 1"
output: rmarkdown::github_document
---

## Set up


Load R libraries
```{r message=FALSE}
# load packages
library(tidyverse)
library(rmarkdown)
library(rlang)
library(parameters)
library(RColorBrewer)
library(ComplexHeatmap)
library(circlize)
library(Matrix)
library(glue)
library(fgsea)
library(DESeq2)
library(ggforestplot)
library(ggbeeswarm)
library(patchwork)
library(lme4)
library(ggstance)
library(knitr)
library(grid)
library(reticulate)

use_python("/projects/home/nealpsmith/.conda/envs/updated_pegasus/bin/python")


setwd('/projects/home/ikernin/github_code/myocarditis/functions')
source('de.R')
source('gsea.R')
source('masc.R')
source('plot_masc.R')
source('blood_abundance.R')
```

Load Python packages
```{python load_python_packages}
import pegasus as pg
import warnings
import os
warnings.filterwarnings('ignore')

import sys
sys.path.append("/projects/home/ikernin/github_code/myocarditis/functions")
import python_functions
```

Read in single-cell data

```{python results = 'hide', read_data}
tissue_global = pg.read_input('/projects/home/ikernin/projects/myocarditis/github_datasets/tissue_global.zarr')
blood_global = pg.read_input('/projects/home/ikernin/projects/myocarditis/github_datasets/blood_global.zarr')
```

## Figure 1A

```{r message=FALSE, fig.width = 15, fig.height = 10, fig_1a}
# read in data
formatted_df <- read_csv('/projects/home/ikernin/github_repos/test_myocarditis/tables/tidy_fig1A.csv')

# get matrix
mtx <- formatted_df %>%
  select(!donor) %>%
  as.matrix()
rownames(mtx) <- formatted_df$donor
mtx <- t(mtx)
mtx[which(is.na(mtx))] <- 0
rownames(mtx) <- c('Age', 'Sex:Male', 'Fatal',
                   'Combination Therapy', 'sc-Heart',
                   'sc-PBMC', 'bulk-Heart', 'bulk-Tumor', 'Serum')

# color fatal sample names
col_name_color <- unname(ifelse(mtx['Fatal',] == '1', 'red', 'black'))
mtx <- mtx[which(rownames(mtx) != 'Fatal'), ] # remove fatal row

# col split
col_split <- factor(c(rep('Myocarditis', 28), rep('Control', 8)))
col_split <- fct_inorder(col_split)

# row split
row_split <- c(rep('meta', 3), rep('analyses',5))
row_split <- factor(row_split, levels=unique(row_split))

# colors
col_age = c(brewer.pal(9, 'YlOrRd'), '#400010')
make_rect <- function(j, i, x, y, width, height, fill) {
  grid.rect(x = x, y = y,
            width = width, height = height,
            gp = gpar(col = "black"))
  if (i == 1){ # ie age
    grid.rect(x = x, y = y,
              width = width, height = height,
              gp = gpar(fill = col_age[as.numeric(mtx[i,j])], col='black'))
  }
  else if (as.numeric(mtx[i,j]) == 1){
    grid.rect(x = x, y = y,
              width = width, height = height,
              gp = gpar(col="black", fill='#5A5A5A'))
  } else if (as.numeric(mtx[i,j]) == 0){
    grid.rect(x = x, y = y,
              width = width, height = height,
              gp = gpar(col="black", fill='white'))
  }
}

# make heatmap body
ht <- Heatmap(mtx,
        cell_fun = make_rect,
        rect_gp = gpar(type = "none"),
        border_gp = gpar(col = "black"),
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        row_title = NULL,
        row_split = row_split,
        row_gap = unit(2, 'mm'),
        column_names_gp = gpar(col = col_name_color),
        column_names_side = "top",
        show_heatmap_legend = FALSE,
        row_names_side = "left",
        show_column_names = TRUE,
        column_split = col_split,
        column_names_rot=45,
        width = ncol(mtx)*unit(6, "mm"),
        height = nrow(mtx)*unit(6, "mm"),
        column_gap = unit(3, "mm"))


# make legends
age_lgd <- Legend(labels = c("20-25","40-45","50-55","55-60","60-65",
                               "65-70","70-75","75-80","80-85","85-90"),
                  title = "Age",
                  legend_gp = gpar(fill=col_age),
                  border = 'black')

fill_lgd <- Legend(labels = c('True', 'False'),
                   title = 'Fill',
                   labels_gp = gpar(col = c('black', 'black')),
                   legend_gp = gpar(fill=c('#5A5A5A', 'white')),
                   border = 'black')

fatal_lgd <- Legend(labels = c('Non-Fatal', 'Fatal'),
                   title = 'Name',
                   labels_gp = gpar(col = c('black', 'red')),
                   legend_gp = gpar(fill= c('white', 'white')))

pd <- packLegend(age_lgd, fill_lgd, fatal_lgd,
                 max_height = nrow(mtx)*unit(6, "mm"))


draw(ht)
draw(pd, x = unit(0.93, "npc"), y = unit(0.43, "npc"))

```


## Figure 1B

```{r fig_1B, message = FALSE, warning = FALSE, fig.width = 12, fig.height = 5}
all_info <- read.csv("/projects/home/nealpsmith/projects/myocarditis/data/global_clustering_obs.csv")

all_info$on_steroids[all_info$donor == "SIC_232"] <- "False"

# Lets make a column that combines the technical replicates
atlas_meta <- read.csv("/projects/home/nealpsmith/projects/myocarditis/data/heart_atlas_meta.csv")

atlas_meta$Donor <- paste("sanger", atlas_meta$Donor, sep = "_")

all_info$summary_channel <- sapply(all_info$Channel, function(x){
  if (str_detect(x, "HCA")){
    meta <- atlas_meta %>% dplyr::filter(Sanger.ID == x)
    return(paste(meta$Donor, meta$Source, sep = "_"))
  } else {
    return(sub("*_[1-2]_heart", "", x))
  }
})

# Lets start building this matrix
heatmap_df <- matrix(nrow =1, ncol = length(unique(all_info$summary_channel))) %>%
  as.data.frame() %>%
  `colnames<-`(unique(all_info$summary_channel)) %>%
  `rownames<-`(c("myocarditis"))

# Enrichment strategy
cd45_enriched <- all_info %>%
  dplyr::select(summary_channel, source) %>%
  distinct() %>%
  dplyr::filter(source == "CD45+") %>%
  .$summary_channel

heatmap_df["CD45 enriched",] <- ifelse(colnames(heatmap_df) %in% cd45_enriched, "True", "False")

# Everyone contributed to clustering
heatmap_df["Clustering",] <- "True"

# Myo vs. control
myo_ctrl_info <- all_info %>%
  dplyr::select(summary_channel, condition) %>%
  distinct()

heatmap_df["myocarditis",] <- sapply(colnames(heatmap_df), function(x){
  if (myo_ctrl_info$condition[myo_ctrl_info$summary_channel == x] == "myocarditis"){
    return("True")
  } else {
    return("False")
  }
})

# Now steroid
on_steroids <- all_info %>%
  dplyr::select(summary_channel, on_steroids) %>%
  distinct() %>%
  dplyr::filter(on_steroids == "True") %>%
  .$summary_channel

heatmap_df["steroid",] <- ifelse(colnames(heatmap_df) %in% on_steroids, "True", "False")

# Now the DEGs
heatmap_df["DEG analysis",] <- sapply(colnames(heatmap_df), function(x){
  if (heatmap_df["steroid",x] == "True"){
    return("False")
  } else {
    return("True")
  }
})

# Abundance analysis
heatmap_df["Abundance analysis",] <- sapply(colnames(heatmap_df), function(x){
  if (heatmap_df["steroid",x] == "False" & heatmap_df["CD45 enriched", x] == "False"){
    return("True")
  } else {
    return("False")
  }
})


# TCR analyses
tcr_info <- read.csv("/projects/myocarditis/neal/data/myo_v2_tcells_res_1_1_complete_with_pb_and_tcr.csv",
                             row.names = 1)
tcr_info$has_clone <- ifelse(tcr_info$TRB_cdr3 != "", "True", "False")

tcr_info$summary_channel <- sapply(tcr_info$Channel, function(x){
  if (str_detect(x, "HCA")){
    meta <- atlas_meta %>% dplyr::filter(Sanger.ID == x)
    return(paste(meta$Donor, meta$Source, sep = "_"))
  } else {
    return(sub("*_[1-2]_heart", "", x))
  }
})

has_tcr <- tcr_info %>%
  dplyr::filter(has_clone == "True") %>%
  dplyr::select("summary_channel", "has_clone") %>%
  distinct() %>%
  .$summary_channel

heatmap_df["TCR analysis",] <- ifelse(colnames(heatmap_df) %in% has_tcr, "True", "False")

# Lets order the columns
heatmap_order <- c(colnames(heatmap_df)[heatmap_df["myocarditis",] == "True" & heatmap_df["steroid",] == "False"],
                   colnames(heatmap_df)[heatmap_df["myocarditis",] == "True" & heatmap_df["steroid",] == "True"],
                   colnames(heatmap_df)[heatmap_df["myocarditis",] == "False" & grepl("SIC", colnames(heatmap_df))],
                   colnames(heatmap_df)[heatmap_df["myocarditis",] == "False" & grepl("CD45+", colnames(heatmap_df))],
                   colnames(heatmap_df)[heatmap_df["myocarditis",] == "False" & grepl("Cells", colnames(heatmap_df))])

heatmap_df <- heatmap_df[,heatmap_order]


# Bottom bar/split
samp_info <- all_info %>%
  dplyr::select(summary_channel, condition, source, institution) %>%
  distinct()
samp_info$source[samp_info$source == "sorted"] <- "Cells"

cols <- list("myocarditis_pre_ster_mgh" = "#0072B2",
             "myocarditis_post_ster_mgh" = "#E69F00",
             "control_native_mgh" = "#56B4E9",
             "control_native_sanger" = "#009E73",
             "control_cd45_sanger" = "#F0E442")
group_cols <- c()
split <- c()
for (samp in colnames(heatmap_df)){
  if (grepl("sanger", samp)){
    if (grepl("Cells", samp)){
      group_cols <- c(group_cols, c(cols[["control_native_sanger"]]))
      split <- c(split, c("Sanger native"))
    } else {
      group_cols <- c(group_cols, c(cols[["control_cd45_sanger"]]))
      split <- c(split, c("Sanger CD45+"))
    }
  } else if (grepl("SIC_182|SIC_333", samp)){
    group_cols <- c(group_cols, c(cols[["control_native_mgh"]]))
    split <- c(split, c("MGH native"))
  } else if (heatmap_df["steroid",samp] == "False"){
    group_cols <- c(group_cols, c(cols[["myocarditis_pre_ster_mgh"]]))
    split <- c(split, c("MGH pre-steroid"))
  } else {
    group_cols <- c(group_cols, c(cols[["myocarditis_post_ster_mgh"]]))
    split <- c(split, c("MGH post-steroid"))
  }
}

split <- factor(split, levels = c("MGH pre-steroid", "MGH post-steroid", "MGH native", "Sanger CD45+", "Sanger native"))

# Okay want to get the columns ordered by cell # now (this is some ASS code, relies on level order of "split")
heatmap_order <- c()
for (cat in levels(split)){
  samps <- colnames(heatmap_df[,grep(cat, split)])
  new_ord <- all_info %>%
    dplyr::select(barcodekey, summary_channel) %>%
    dplyr::filter(summary_channel %in% samps) %>%
    group_by(summary_channel) %>%
    summarise(n_cells = n()) %>%
    arrange(desc(n_cells)) %>%
    .$summary_channel
  heatmap_order <- c(heatmap_order, new_ord)
}

heatmap_df <- heatmap_df[,heatmap_order]



# Now the colors
cat_colors <- structure(c("#5A5A5A", "white"), names = c("True", "False"))

# Lets do the # of cells bar
cell_number <- all_info %>%
  dplyr::select(barcodekey, summary_channel) %>%
  group_by(summary_channel) %>%
  summarise(n_cells = n()) %>%
  column_to_rownames("summary_channel") %>%
  .[heatmap_order,]

cell_codes = all_info[all_info$summary_channel == "sanger_6_Cells",]$barcodekey
cd45_codes = all_info[all_info$summary_channel == "sanger_6_CD45+",]$barcodekey

cell_codes <- sapply(cell_codes, function(x) strsplit(x, "_")[[1]][2])
cd45_codes <- sapply(cd45_codes, function(x) strsplit(x, "_")[[1]][2])

breaks = c(1, 10, 100, 1000, 10000)

# Need the top bar too
perc_lin <- all_info %>%
  dplyr::select(summary_channel, lineage1) %>%
  group_by(summary_channel, lineage1) %>%
  summarise(n_cells = n()) %>%
  group_by(summary_channel) %>%
  mutate(perc_cells = n_cells / sum(n_cells))

perc_lin_mtx <- matrix(ncol = length(unique(perc_lin$lineage1)),nrow = length(unique(perc_lin$summary_channel))) %>%
  `rownames<-`(unique(perc_lin$summary_channel)) %>%
  `colnames<-`(unique(perc_lin$lineage1))

for (n in rownames(perc_lin_mtx)){
  for (l in colnames(perc_lin_mtx)){
    val <- perc_lin[perc_lin$summary_channel == n & perc_lin$lineage1 == l,]$perc_cells
    if (length(val) > 0){
      perc_lin_mtx[n,l] <- val
    } else {
      perc_lin_mtx[n,l] <- 0
    }
  }
}

lin_cols = list("lineage" = c('Endothelial cells'= '#ff0029',
                              'Mural cells'= '#377eb8',
                              'T and NK cells'= '#66a61e',
                              'Myeloid cells'= '#984ea3',
                              'Fibroblasts'= '#00d2d5',
                              'Doublets and RBC'= '#ff7f00',
                              'Cardiomyocytes'= '#af8d00',
                              'Dendritic cells'= '#7f80cd',
                              'Neuronal cells'= '#b3e900',
                              'B and plasma cells'= '#c42e60'))
perc_lin_mtx <- perc_lin_mtx[colnames(heatmap_df),names(lin_cols$lineage)]

lin_col_list = sapply(colnames(perc_lin_mtx), function(x) lin_cols$lineage[[x]])
n_cell_bar = HeatmapAnnotation("# cells" = anno_barplot(log10(cell_number), height = unit(2, "cm"),
                                                        axis_param = list(at = log10(breaks), labels = breaks)),
                               "cell fraction" = anno_barplot(perc_lin_mtx, height = unit(2, "cm"), gp = gpar(fill = lin_col_list),
                               ), gap = unit(2.5, "mm"))

# Lets make a legend for the bar
lin_legend <- Legend(labels = colnames(perc_lin_mtx), legend_gp = gpar(fill = lin_col_list), title = "Lineage")

library(GetoptLong)  # for the function qq()
bottom_annotation <- HeatmapAnnotation(names = anno_text(colnames(heatmap_df), which = "column"),
                                       inst = anno_empty(border = FALSE, height = unit(3.5, "mm")),
                                       blk = anno_block(gp = gpar(fill = unlist(cols, use.names = FALSE)), labels = levels(split),
                                                        labels_gp = gpar(col = "black", fontsize = 5, fontface = "bold"),
                                                        height = unit(3.5, "mm")), which = "column")


group_block_anno = function(group, empty_anno, gp = gpar(),
    label = NULL, label_gp = gpar()) {

    seekViewport(qq("annotation_@{empty_anno}_@{min(group)}"))
    loc1 = deviceLoc(x = unit(0, "npc"), y = unit(0, "npc"))
    seekViewport(qq("annotation_@{empty_anno}_@{max(group)}"))
    loc2 = deviceLoc(x = unit(1, "npc"), y = unit(1, "npc"))

    seekViewport("global")
    grid.rect(loc1$x, loc1$y, width = loc2$x - loc1$x, height = loc2$y - loc1$y,
        just = c("left", "bottom"), gp = gp)
    if(!is.null(label)) {
        grid.text(label, x = (loc1$x + loc2$x)*0.5, y = (loc1$y + loc2$y)*0.5, gp = label_gp)
    }
}
# Want to remove a couple of rows we don't need anymore
heatmap_df <- heatmap_df[-c(1,2, 4),]

legend_list <- packLegend(lin_legend)

hmap <- Heatmap(heatmap_df, name = " ", col = cat_colors,
        rect_gp = gpar(col = "black", lwd = 1), cluster_columns = FALSE,
        cluster_rows = FALSE, top_annotation = n_cell_bar,
        show_column_names = FALSE, column_title = NULL, column_title_side = "bottom",
        column_title_gp = gpar(fontsize = unit(5, "cm")),
        bottom_annotation = bottom_annotation, column_split = split, show_heatmap_legend = FALSE)

draw(hmap, heatmap_legend_list = legend_list)
group_block_anno(1:2, "inst", gp = gpar(fill = "#8B3626"), label = "Myocarditis", label_gp = gpar(col = "white",
                                                                                              fontsize = 8, fontface = "bold"))
group_block_anno(3:5, "inst", gp = gpar(fill = "#708090"), label = "Control", label_gp = gpar(col = "white",
                                                                                           fontsize = 8, fontface = "bold"))
```

## Figure 1C

```{python results = 'hold', fig_1c}
python_functions.plot_umap(tissue_global, 'Tissue: Global', python_functions.tissue_global_pal)
python_functions.plot_umap(blood_global, 'Blood: Global', python_functions.blood_global_pal, marker_multiplier=28)
```


## Figure 1D

```{r message = F, results = 'hold', fig.width = 15, fig.height = 10, fig_1d}
# read in tissue cell metadata
tissue_global_obs = read_csv('/projects/home/ikernin/projects/myocarditis/github_datasets/tissue_global_obs.csv')
filtered_df  <- masc_filter(tissue_global_obs)

# run masc analysis
lineage_masc_res <- MASC(filtered_df,
                         cluster = filtered_df$umap_number,
                         contrast = "condition",
                         random_effects = "donor",
                         fixed_effects = "",
                         verbose = TRUE, save_models = FALSE)

# add cluster information to results
lineage_masc_formatted <- lineage_masc_res %>%
  as_tibble() %>%
  mutate(lineage_number = unlist(map( str_split(cluster, 'cluster'), 2)),
         lineage_number = as.numeric(lineage_number)) %>%
  left_join(filtered_df %>%
              select(umap_name, umap_number) %>%
              distinct(),
            by = c('lineage_number' = 'umap_number')) %>%
  mutate(lineage_names = unlist(map(str_split(umap_name, '\\. '), 2))) %>%
  relocate(lineage_names, lineage_number) %>%
  select(!c(cluster, umap_name))

# FDR adjust p-values
lineage_masc_formatted['p.adj'] <- p.adjust(lineage_masc_formatted$model.pvalue, method = 'fdr')
kable(lineage_masc_formatted)

# plot results
plot_masc_by_lineage(lineage_masc_formatted, filtered_df)
```


## Figure 1E

```{r message = F, results = 'hold', fig_1e}
# read in all blood cell metadata
blood_global_obs <- read_csv('/projects/home/ikernin/projects/myocarditis/github_datasets/blood_global_obs.csv')
fatal_blood_obs_filtered <- fatal_filter_df(blood_global_obs)

# fit lineage level model
lineage_order <- c("Myeloid", "CD8 and NK", "CD4", "B and Plasma", "pDCs and cDCs")
fatal_lineage_percents <- fatal_get_percent_per_level(fatal_blood_obs_filtered, level='lineage') %>%
    set_factor_order(col_name = 'lineage_names', order = lineage_order)
fatal_lineage_model <- fatal_fit_model(fatal_lineage_percents, level='lineage')
kable(fatal_lineage_model %>%
              select(!c(data, model)) %>%
              unnest(cols = c(fatal_coef, fatal_se, fatal_pval)))

fatal_plot_sample_perc(fatal_lineage_percents, title='Blood Global', level='lineage')
fatal_plot_ci_interval(fatal_lineage_model, 'Blood Global', level='lineage')

```


## Figure 1I

```{python results = 'hold', fig_1i}
adata = pg.read_input('/projects/home/sramesh/myo_final/blood/final/myo_blood_global.zarr')
adata.obs['umap_name'] = adata.obs['lineage'].astype('category')
lineage_order = adata.obs['lineage'].value_counts().index.to_list()
lineage_order = [i for i in lineage_order if i != 'Doublets and RBCs'] + ['Doublets and RBCs']
lineage_dict = dict(zip(lineage_order, range(1, len(lineage_order) + 1)))
adata.obs['umap_number'] = adata.obs['umap_name'].map(lineage_dict).astype('category')
python_functions.plot_umap(adata, '', python_functions.blood_global_pal)
```

## Figure 1J
```{r message = F, results = 'hold', fig_1j}
setwd('/projects/home/sramesh/github/myocarditis')

### Read in obs matrix and cluster annotations
obs <- read_csv(glue('/projects/home/sramesh/myo_final/blood/final/myo_blood_global_obs.csv'))
cluster_annots <- readxl::read_excel('/projects/home/sramesh/myo_final/blood/other_stuff/cluster_annotations.xlsx')

## Figure 1J
# run masc for case vs control by lineage (or read in file if it exists)
if (!file.exists('output/masc_for_deg_case_control_by_cluster.csv')) {
  lineage_masc_res <- run_masc(obs,
                               c('deg_case_control', 'control', 'case'),
                               'lineage',
                               fixed_effects = c('sex', 'ici_type'))
  write_csv(lineage_masc_res, 'output/masc_for_deg_case_control_by_lineage.csv')
} else {
  lineage_masc_res <- read_csv('output/masc_for_deg_case_control_by_lineage.csv')
}

masc_helper(obs,
            c('deg_case_control', 'control', 'case'),
            'lineage',
            fixed_effects = c('sex', 'ici_type'),
            group_subset=NULL,
            masc_res=lineage_masc_res,
            colors=c('tomato4', 'slategray'))

```

## Figure 1K

```{python results = 'hold', fig_1k_python}
os.chdir('/projects/home/sramesh/github/myocarditis')

counts, meta = python_functions.blood_pb_info('/projects/home/sramesh/myo_final/blood/final/myo_blood_global.zarr',
                                              'sample_id',
                                              'lineage',
                                              ['steroid_treatment', 'post_steroid_fatal', 'deg_case_control',
                                              'condition', 'lineage', 'sex', 'ici_type', 'on_ici_vs_control'])
counts.to_csv('output/pb_counts_by_sample_id_and_lineage.csv')
meta.to_csv('output/pb_meta_by_sample_id_and_lineage.csv')
```

```{r message = F, results = 'hold', fig_1k_r}
setwd('/projects/home/sramesh/github/myocarditis')

#### first run de
counts <- read_counts("output/pb_counts_by_sample_id_and_lineage.csv")
meta <- read_meta("output/pb_meta_by_sample_id_and_lineage.csv")
meta <- meta %>%
  filter(deg_case_control != "NA") %>%
  filter(!str_detect(lineage, "Doublet"))
case_control_contrast_vec <- c('deg_case_control', 'case', 'control')
case_control_lineage_results <- run_de_by_comp_var(counts, meta, 'output/lineage', case_control_contrast_vec,
                                                   deseq_formula = formula("~ deg_case_control + sex + ici_type"))

#### then run gsea on de results
case_control_lineage_gsea <- run_gsea(case_control_lineage_results)
write_csv(case_control_lineage_gsea, 'output/gsea_by_deg_case_control_by_lineage.csv')

#### make heatmap
pathways <- c('KEGG_ALLOGRAFT_REJECTION', 'KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION',
              'KEGG_CELL_ADHESION_MOLECULES_CAMS', 'KEGG_DNA_REPLICATION', 'HALLMARK_INTERFERON_GAMMA_RESPONSE',
              'KEGG_VIRAL_MYOCARDITIS')
pathway_abbrevs <- c('KEGG: Allo', 'KEGG: AP', 'KEGG: CAMS', 'KEGG: DNA', 'HALLMARK: IFNG', 'KEGG: Viral Myo')
abbrev_dict <- setNames(pathway_abbrevs, pathways)
lineage_order <- c('pDCs', 'cDCs', 'B and plasma', 'MNP', 'CD4', 'CD8 and NK')

heatmap_df <- case_control_lineage_gsea %>%
  complete(pathway, cluster) %>%
  replace_na(list(log2FoldChange = 0, padj = 1)) %>%
  select(pathway, cluster, NES, padj) %>%
  filter(pathway %in% pathways) %>%
  mutate(cluster = str_replace_all(cluster, '_', ' ')) %>%
  mutate(pathway = abbrev_dict[pathway])

# Format main body:
# get information for the main body's cells
# not replacing NA values so they are colored gray in heatmap
nes_mtx <- heatmap_df %>%
  select(c(pathway, cluster, NES)) %>%
  pivot_wider(names_from = cluster, values_from = NES) %>%
  column_to_rownames('pathway') %>%
  select(all_of(lineage_order)) %>%
  as.matrix()
nes_mtx <- nes_mtx[pathway_abbrevs,] %>% t()

# define cell color range
heatmap_col_fun <- colorRamp2(c(floor(min(nes_mtx, na.rm = T)), 0, ceiling(max(nes_mtx, na.rm = T))),
                              brewer.pal(5, 'PiYG')[c(5,3,1)])

# Main body annotation (FDR):
# get fdr values
# not replacing NA values so they are colored gray in heatmap
fdr_mtx <- heatmap_df %>%
  select(c(pathway, cluster, padj)) %>%
  pivot_wider(names_from = cluster, values_from = padj) %>%
  column_to_rownames('pathway') %>%
  select(all_of(lineage_order)) %>%
  as.matrix()
fdr_mtx <- fdr_mtx[pathway_abbrevs,] %>% t()

# make function for plotting fdr value (this function returns a function)
fdr_func <- function(mtx) {
  function(j, i, x, y, width, height, fill) {
    if (!is.na(mtx[i, j]) & (mtx[i,j] < 0.1)) {
      grid.circle(x = x, y = y, r = unit(1.5, 'mm'),
                  gp = gpar(fill = 'black', col = NA))
    }
  }
}

# make sure columns are the same
stopifnot(colnames(fdr_mtx) == colnames(nes_mtx))
stopifnot(rownames(fdr_mtx) == rownames(nes_mtx))

# Legends
gsea_lgd <- Legend(col_fun = heatmap_col_fun, title = 'NES', direction = 'horizontal')
fdr_lgd <- Legend(pch = 16, type = "points", labels = "FDR < 0.1")
na_lgd <- Legend(labels = 'N/A', legend_gp = gpar(fill = 'grey'))
pd <- packLegend(gsea_lgd, fdr_lgd, na_lgd, direction = 'horizontal')

# Plot
ht_gsea <- Heatmap(nes_mtx,
                   col = heatmap_col_fun,
                   cell_fun = fdr_func(fdr_mtx),
                   column_order = colnames(nes_mtx),
                   top_annotation = NULL, column_title = NULL,
                   name = 'NES', show_heatmap_legend = FALSE,
                   cluster_columns = FALSE, column_names_side = "top",
                   show_column_names = T, column_names_rot = 45,
                   cluster_rows = FALSE, row_names_side = "left",
                   row_title_rot = 0, row_title_gp=gpar(fontface='bold'),
                   row_gap = unit(2, "mm"), border = TRUE,
                   width = ncol(nes_mtx)*unit(6, "mm"),
                   height = nrow(nes_mtx)*unit(6, "mm"))

draw(ht_gsea,
     heatmap_legend_list = pd,
     heatmap_legend_side = 'bottom',
     merge_legends = FALSE)

```
